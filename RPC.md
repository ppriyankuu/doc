# RPC, JSON-RPC
JSON-RPC is a remote procedure call (RPC) protocol encoded in JSON (Javascript Object Notation). It allows for communication between a client and a server over a network. JSON-RPC enables a client to invoke methods on a server and receive responses, similar to traditional RPC but using JSON for data formatting.

AS a user, you interact with the blockchain for two purposes - 
 - To send a `transaction`.
 - To fetch some details from the blockchain (balances, etc).

In both of these, the way to interact with the blockchain is using JSON-RPC.
JSON-RPC Spec - [click me!!!](https://www.jsonrpc.org/specification)

``There are other ways to do RPC's like GRPC, TRPC``

## Understanding RPC
RPC is a client-server model where the client makes a request to exectue specific procedure or function on the server. The server processes the request, performs the requested operation, and sends the result back to the client. This process is transparent to the client, making it appear as if the procedure is being executed locally.

#### Why use RPC?
1. **Language and Platform independence**: RPC allows applications written in different programming languages and running on different platforms to communicate seamlessly. This promotes code reusability and interoperability across diverse systems.
2. **Abstraction of Communication Details**: RPC abstracts away the complexities of network communication, such as socket programming, serialization, and deserialization of data. Developers can focus on the application logic rather than low-level communication details.
3. **Distributed Computing**: RPC enables the distribution of computational tasks across multiple systems, allowing for better resource utilization, load balancing, and scalability.
4. **Code Modularity**: RPC promotes code modularity by separating the client and server components. This separation of converns makes the codebase more maintainable and easier to evolve.

#### Drawbacks of HTTP for Backend Communication
While HTTP is a widely used protocol for communication between web applications and servers, it has some limitation when it comes to backend-to-backend communication:
1. **Lack of Type Safety**: HTTP requests and responses are typically transmitted as plain text or JSON, which lacks type safety. This can lead to runtime errors and make it harder to ensure data integrity.
2. **Overhead**: HTTP has additional overhead due to headers, parsing, and serialization/deserialization of data, which can impact performance, especially in high-throughput scenarios.
3. **Language Dependency**: HTTP libraries and their usage can vary across programming languages, making it harder to maintain consistent communication patterns across different backend systems.
4. **Limited Funcionality**: HTTP is primarily designed for request-response communication, which may not be suitable for more complex scenarios like bi-directional streaming or long-lived connections.

RPC addresses these limitations by providing a more efficient, language-agnostic, and type-safe communication mechanism for backend systems.

To illustrate RPC in actions, let's consider making a HTTP request:
```javascript
const https = require('https');

const options = {
  hostname: 'sum-server.100xdevs.com',
  port: 443,
  path: '/todos',
  method: 'GET'
};

const req = https.request(options, (res) => {
  console.log(`Status Code: ${res.statusCode}`);

  res.on('data', (chunk) => {
    console.log(`Body: ${chunk}`);
  });

  res.on('end', () => {
    console.log('No more data in response.');
  });
});

req.on('error', (e) => {
  console.error(`problem with request: ${e.message}`);
});

req.end();
```

This code sends an HTTP GET request to the specified URL and logs the response status code and body to the console. While this approach works, it requires handling low-level details like creating the request options, managing the response data, and handling error explicitly.

With RPC, the communication between the client and server would be abstracted away, allowing developers to focus on the application logic rather than underlying communication details.

#### Implementing a Simple RPC
The idea behind implementing a simple RPC is to generate client code that can be used by different programming languages to call functions on a remote service without worrying about the underlying communication details, such as making HTTP requests or handling serialization/deserialization.

###### Autogenerated Client
Let's consider an autogenerated client in TypeScript that can fetch a list of todos from a remote service:
```typescript
// rpc.ts (autogenerated)
import axios from "axios";

interface Todo {
  id: string;
  title: string;
  description: string;
  completed: boolean;
}

async function getTodos(): Promise<Todo[]> {
  const response = await axios.get("<https://sum-server.100xdevs.com/todos>");

  let todos = response.data.todos;
  return todos;
}
```

In this example, the `genTodos` function is autogenerated and uses the axios library to to make an HTTP GET request to the specified URL. The function returns a `Promise` that resolves with an array of `Todo` objects, where the `Todo` interface is also autogenerated based on the expected response shape.

To use this autogenerated client, you can import the `getTodos` function and call it like this:
```typescript
// index.ts
import { getTodos } from "./rpc";

const todos = await getTodos();
console.log(todos);
```

#### Benefits of the Autogenerated Client
1. **Better Type Safety**: The `getTodos` function has an associated type for the data being returned (`Todo[]`), which provides better type safety and helps catch errors during development.
2. **Abstraction of Communication Details**: Developers no longer need to worry about using libraries like `axios` or `fetch` directly. They can simple call the `getTodos` function, which abstracts away the underlying communication details.
3. **Language Agnostic**: By autogenerating clients for different programming languages, this approach becomes language-agnostic, allowing backend systems written in different languauges to communicate seamlessly.

#### Sample Clients in other languages
To illustrate the language-agnostic nature of this approach, here are sample clients for the same `getTodos` function in Rust and Go:
**Rust**
```rust
use reqwest::Error; // Add reqwest = { version = "0.11", features = ["blocking", "json"] } in Cargo.toml

#[derive(Debug)]
struct Todo {
    id: String,
    title: String,
    description: String,
    completed: bool,
}

async fn get_todos() -> Result<Vec<Todo>, Error> {
    let response = reqwest::get("<https://sum-server.100xdevs.com/todos>").await?;

    let todos: Vec<Todo> = response.json().await?;
    Ok(todos)
}
```
**Go**
```go
import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

type Todo struct {
	ID          string `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Completed   bool   `json:"completed"`
}

func getTodos() ([]Todo, error) {
	response, err := http.Get("<https://sum-server.100xdevs.com/todos>")
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	var todos struct {
		Todos []Todo `json:"todos"`
	}
	if err := json.Unmarshal(body, &todos); err != nil {
		return nil, err
	}

	return todos.Todos, nil
}
```

These examples demonstrate how the autogenerated client can be used in different programming languages, providing a consitent and language-agnostic way to communicate with the remote service.
```
While this approach is a step towards a more efficient and type-safe communication mechanism, it still relies on JSON for serialization/deserialization, which can be slow compared to other formats like Protocol Buffers or gRPC.
```